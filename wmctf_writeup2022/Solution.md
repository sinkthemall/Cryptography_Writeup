# WMCTF 2022 writeup - Cryptography
## 1. ECC
```
flag bits: 606
e = 0x10001
n = 61262574892917665379101848600282751252633178779864648655116434051615964747592676204833262666589440081296571836666022795166255640192795587508845265816642144669301520989571990670507103278098950563219296310830719975959589061794360407053224254135937766317251283933110936269282950512402428088733821277056712795259
c = 16002162436420434728223131316901476099110904029045408221515087977802746863468505266500673611412375885221860212238712311981079623398373906773247773552766200431323537510699147642358473715224124662007742017000810447999989426207919068340364725395075614636875116086496704959130761547095168937180751237132642548997
G = (3364552845709696244757995625685399274809023621531082895612949981433844727622567352338990765970534554565693355095508508160162961299445890209860508127449468 : 4874111773041360858453223185020051270111929505293131058858547656851279111764112235653823943997681930204977283843433850957234770591933663960666437259499093 : 1)
3G = (8240596254289477251157504980772167439041663401504657696787046343848644902166655624353107697436635678388969190302189718026343959470011854412337179727187240 : 4413479999185843948404442728411950785256136111461847698098967018173326770728464491960875264034301169184074110521039566669441716138955932362724194843596479 : 1)
```
We are given a file which contains somekind of encryptions like RSA and ECC.
My first idea is that p (factor of n) might be the modulus of EC, so if we can find the modulus base on 2 points on the curve (G and 3G), we can decrypt c and get the flag.  
The idea to get the p base on two points:
-   Let's call G and 3G are (x1,y1) and (x2,y2)
-   We know that EC equation is ``` y^2 = x^3 + ax + b ( mod p) ```, if we replace (x1,y1) and (x2,y2) into the equation, we will get 2 different equations ``` y1^2 = x1^3 + ax1 + b ``` and ``` y2^2 = x2^3 + ax2 + b ```, subtracting it and we get 
``` y2^2 - y1^2 = (x2^3 - x1^3) + a(x2 - x1) ```. At this point, we can find A and B (modulo n).
-   Define f = x - A(mod n), we can use the small_roots method in sagemath to find the value x by setting ``` beta = 0.5 ```( we already know A is one root of f, but we want to find the smaller root, which is the real A modulo p)
-   After finding A, we can find p by computing the GCD of (A(mod n) - A(mod p)) with n
-   Having p and a, we can compute q, d, b easily and restore the flag

But after recovering p,q,d and decrypt C, we notice that it has bit_length less than the original flag's bit_length ``` C's bitlength = 202, flag's bitlength = 606 ```. I guess A and B parameter are also parts of the flag (this one is similar to the threetresures - CorCTF problem), combining them will get the real flag
```
a: 3629864911627283784723617758993690217446918991113173559686999
p: 8308060309959524788634404677678479024666400240233812713350984932475838872076486898595574202532027412806488106365658717017155800093596205985127436125626827
q: 7373872192463191738033336697886150566044010386580579101665086651212656675570461681793837375772679015765588192207913025640568056955479671819537473774809617
b: 988958437986133278846018591274848194060347135958347118693976
a's bit_length: 202
b's bit_length: 200
c's bit_length: 201
b'$$U_c0u1d_s01v3_e11iptiCurv3_s0_34sily$$0f19d82199a0db0dee31fa12330307ea90aa'
```
source code:
```python 
n = 61262574892917665379101848600282751252633178779864648655116434051615964747592676204833262666589440081296571836666022795166255640192795587508845265816642144669301520989571990670507103278098950563219296310830719975959589061794360407053224254135937766317251283933110936269282950512402428088733821277056712795259
e = 65537
c = 16002162436420434728223131316901476099110904029045408221515087977802746863468505266500673611412375885221860212238712311981079623398373906773247773552766200431323537510699147642358473715224124662007742017000810447999989426207919068340364725395075614636875116086496704959130761547095168937180751237132642548997
gx = 3364552845709696244757995625685399274809023621531082895612949981433844727622567352338990765970534554565693355095508508160162961299445890209860508127449468
gy = 4874111773041360858453223185020051270111929505293131058858547656851279111764112235653823943997681930204977283843433850957234770591933663960666437259499093
g3x = 8240596254289477251157504980772167439041663401504657696787046343848644902166655624353107697436635678388969190302189718026343959470011854412337179727187240
g3y = 4413479999185843948404442728411950785256136111461847698098967018173326770728464491960875264034301169184074110521039566669441716138955932362724194843596479
A = (((g3y^2 - gy^2) - (g3x^3 - gx^3))%n *pow((g3x - gx), -1, n))%n # modulo n
b = (gy^2 - gx^3 - A*gx)%n
P.<x> = PolynomialRing(Zmod(n))
f = x - A
#print("A:", A)
a = 0
i = 0
while True:# i am not sure about the actual upper bound of a, so i just bruteforce it
    q = f.small_roots(beta = 0.5, X = 2^i)
    if len(q) != 0:
        #print(q)
        a = q[0]
        break
    i += 1

print("a:", a)
from math import gcd 
p = gcd(A - a, n)
assert(p != n and p!= 1)
print("p:", p)
q = n// p 
print("q:", q)
d = pow(e, -1, (p-1)*(q-1))
c = pow(c, d, n)
b = (gy^2 - gx^3 - a*gx)%p 
print("b:", b)
print("a's bit_length:", int(a).bit_length())
print("b's bit_length:", int(b).bit_length())
print("c's bit_length:", int(c).bit_length())
from Crypto.Util.number import long_to_bytes
flag = (int(a)<<int(404)) | (int(b)<<int(202)) | int(c) 
print(long_to_bytes(flag))
```
## 2. nanoDiamond
https://github.com/sinkthemall/Cryptography_Writeup/tree/main/wmctf_writeup2022/problem/nanoDiamond
