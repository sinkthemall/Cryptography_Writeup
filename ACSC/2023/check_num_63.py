# f = open("d:\\output.txt")
# checkkey = []
# for i in f.readlines()[1:]:
#     q = i.replace("\n", "").split(":")
#     checkkey.append((int(q[0]), int(q[1])))

# print(checkkey)


checkkey = [(65537, 36212), (65539, 5418), (65543, 27200), (65551, 37275), (65557, 19020), (65563, 18986), (65579, 30121), (65581, 55506), (65587, 34241), (65599, 35120), (65609, 49479), (65617, 38310), (65629, 65504), (65633, 15629), (65647, 27879), (65651, 6535), (65657, 24690), (65677, 57656), (65687, 58616), (65699, 19857), (65701, 9326), (65707, 8739), (65713, 60630), (65717, 35109), (65719, 47240), (65729, 12246), (65731, 35776), (65761, 23462), (65777, 48929), (65789, 13100), (65809, 10941), (65827, 55227), (65831, 21264), (65837, 36029), (65839, 1057), (65843, 11772), (65851, 30488), (65867, 45637), (65881, 40155), (65899, 42192), (65921, 64114), (65927, 8091), (65929, 5184), (65951, 8153), (65957, 33274), (65963, 17143), (65981, 7585), (65983, 62304), (65993, 58644), (66029, 15067), (66037, 47377), (66041, 35110), (66047, 30712), (66067, 4519), (66071, 53528), (66083, 1925), (66089, 29064), (66103, 32308), (66107, 52310), (66109, 13040), (66137, 27981), (66161, 36954), (66169, 9902)]
residue = []
modulo = []
n= 24575303335152579483219397187273958691356380033536698304119157688003502052393867359624475789987237581184979869428436419625817866822376950791646781307952833871208386360334267547053595730896752931770589720203939060500637555186552912818531990295111060561661560818752278790449531513480358200255943011170338510477311001482737373145408969276262009856332084706260368649633253942184185551079729283490321670915209284267457445004967752486031694845276754057130676437920418693027165980362069983978396995830448343187134852971000315053125678630516116662920249232640518175555970306086459229479906220214332209106520050557209988693711

for e, k in checkkey : 
    mod = e 
    r = ((k*n + 1 + k)*pow(k, -1, e)) % e
    residue.append(r)
    modulo.append(e)
#recalculate crt by hand
from sympy.ntheory.modular import crt 

def crt_by_hand(residue, modulo):
    N = 1
    for  i in modulo:
        N*= i
    #print("N's bit length:", N.bit_length())
    ans = 0
    for i in range(len(residue)):
        y = N // modulo[i]
        z = pow(y, -1, modulo[i])
        ans += (residue[i] * y * z)
        ans %= N
    return ans
def solving_p_q(p_q, n):
    a = p_q
    delta = a*a - 4*n
    try:
        idelta, F = iroot(delta, 2)
        assert(F == True)
        ans1 = (a - idelta)//2
        ans2 = (a + idelta)//2
        return ans1,ans2
    except:
        return -1, -1
from gmpy2 import iroot
# from sympy.ntheory.modular import crt
#missing 1 equation, so have to bruteforce

P = -1
Q = -1

for k in range(2, 133087):
    res = residue + [k]
    mod = modulo + [133087]

    p_q = crt(mod, res)[0]
    p, q = solving_p_q(p_q, n)
    if p == -1:
        pass
    else:
        if p * q==n:
            P = p 
            Q = q
            break

from hashlib import sha512


print(P)
print(Q)
if P > Q:
    P, Q = Q, P
print("ACSC{" + sha512(f"{P}{Q}".encode()).hexdigest() + "}")




    


